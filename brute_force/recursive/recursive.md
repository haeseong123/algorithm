# 재귀 함수

재귀 함수란 함수 내에서 자기 자신을 호출하는 것을 말합니다. 즉, 함수가 **자기 자신을 호출하여 문제를 해결**하는 방법입니다. 재귀 함수를 사용하면 이러한 재귀적인 호출을 통해 **작은 부분 문제를 해결하고,
이를 조합하여 최종적인 해답**을 얻을 수 있습니다. 어려운 문제를 쉬운 문제로 나누어 푼 뒤 그것들의 답을 통해 어려운 문제의 답을 구할 수 있는 것이 재귀 함수의 장점입니다.

또한 재귀 함수는 **반드시 탈출 조건**이 있어야 합니다. 만약 탈출 조건이 없다면 무한히 재귀 함수가 호출되어 무한 루프에 빠질 수 있습니다.

어떤 문제가 **재귀 함수를 적용할 수 있는 문제인지 확인**하려면 그 **문제가 반복 가능한 작은 문제로 나뉘어 지는지를 확인**해야 합니다. 즉, 문제를 더 작은 부분 문제로 분할할 수 있어야 재귀 함수를 적용할
수 있습니다.

정리하자면 아래와 같습니다.

- 재귀 함수는
    - 자기 자신을 호출하는 함수입니다.
    - 작은 부분 문제를 해결하고, 이를 조합하여 최종적인 해답을 구하는 함수입니다.
    - 작고 반복 가능한 문제로 나누어지는 문제에 적용 가능한 함수입니다.

재귀 함수에 대한 개념을 이해하기 위해 문제를 풀어보며 더 알아보겠습니다.

## 피보나치 수열의 n번째 값 구하기

피보나치 수열의 n번째 값을 구하는 문제는 재귀 함수를 사용하여 해결할 수 있는 대표적인 문제입니다.

피보나치 수열이란 아래와 같이 0, 1로 시작하고 n번째 수는 바로 앞의 두 수를 더한 수를 순서대로 모아놓은 수열을 뜻합니다.

> 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, ...

문제를 풀기 전에 해당 문제가 정말 재귀 함수를 통해 풀 수 있는 문제가 맞는지 확인해 봅시다. 다시 말해, 해당 문제가 작고 반복 가능한 문제로 나누어지는 문제인지 확인해 봅시다.

피보나치 수열의 n번째 수를 구하는 문제는 n-2번째, n-1번째를 구하는 작은 부분 문제로 나눌 수 있습니다. 이어서, n-2번째를 구하는 문제 또한 (n-2)-2번째, (n-2)-1번째를 구하는 작은 부분 문제로
나눌 수 있습니다.

피보나치 수열의 0번째 1번째 수는 각각 0과 1로 정해져 있으므로 n값을 계속 줄여가며 문제를 계속 나누다보면 작은 부분 문제는 결국 풀리고, 작은 문제의 결괏값을 토대로 큰 문제도 풀 수 있습니다. 이는 아래와
같습니다.

- 0번째 수는
    - 0
- 1번째 수는
    - 1
- 2번째 수는 (0번째 수 + 1번째 수)
    - 0 + 1 = 1
- 3번째 수는 (1번째 수 + 2번째 수)
    - 1 + 1 = 2
- 4번째 수는 (2번째 수 + 3번째 수)
    - 1 + 2 = 3
- ...

이처럼 피보나치 수열의 n번째 수를 구하는 문제는 작고 반복 가능한 문제로 나누어지며 부분 문제의 답을 통해 최종적인 해답을 얻을 수 있는 구조를 갖고 있으므로, 재귀 함수를 사용하여 풀 수 있는 문제 입니다.

> 이제 우리는 이러한 구조(작은 부분 문제를 통해 최종적인 해답을 얻을 수 있는 구조)를 갖는
> 문제를 맞닥뜨렸을 때 재귀 함수로 해당 문제를 풀 수 있다는 생각을 할 수 있습니다.

피보나치 수열의 n번째 값을 구하는 문제가 재귀 함수로 풀 수 있는 문제임을 확인하였습니다.

이제 실제 피보나치 수열의 n번째 수를 구하는 재귀 함수를 작성해 봅시다. 이 문제를 푸는 재귀 함수는 아래와 같은 순서를 갖습니다.

1. n이 0 혹은 1인 경우 n을 반환합니다.
2. n-1과 n-2를 매개변수로 넣어 자기 자신을 호출합니다.
3. 2에서 받은 두 값을 더한 뒤 반환 합니다.

재귀 함수는 반드시 탈출 조건이 있어야 한다고 말씀드렸습니다. n이 0 혹은 1인 경우 n을 반환한다는 것이 이 재귀 함수의 탈출 조건입니다.

이를 코드로 나타내면 다음과 같습니다.

```python
def fib(n):
    # fib()의 탈출 조건입니다.
    # 만약 탈출 조건이 없다면 fib()는 
    # 자기 자신을 무한히 호출하여 
    # CPU와 메모리를 지속적으로 소모하다가 
    # 결국 시스템이 다운되거나 프로그램이 비정상적으로 종료될 것입니다.
    if n == 0 or n == 1:
        return n

    return fib(n - 1) + fib(n - 2)
```

탈출 조건이 존재하며, 작은 문제를 해결하여 최종 해답을 얻는 재귀 함수 fib()를 작성하였습니다.

대충 재귀 함수가 무엇인지 감이 오시나요?

참고로 n번째 피보나치 수를 구하는 위 재귀 함수는 완전 탐색 알고리즘은 아닙니다. brute-force search는 모든 가능한 후보를 체계적으로 열거하고 각 후보가 조건을 충족하는지 여부를 확인하는 것인데, 위
재귀 함수는 가능한 모든 후보를 열거하고 하나씩 확인하는 대신, 이전 두 피보나치 수의 값을 기반으로 현재 피보나치 수를 계산하기 위해 재귀 호출을 사용합니다. 이 접근 방식은 모든 가능한 후보를 확인하는 동작을
포함하고 있지 않기 때문에 위 재귀 함수는 완전 탐색 알고리즘으로 볼 수 없습니다.

어떤 재귀 함수는 완전 탐색이지만, 어떤 재귀 함수는 완전 탐색이 아닙니다. 예를 들어, 재귀 함수가 모든 가능한 조합을 탐색하면 해당 재귀 함수는 완전 탐색 알고리즘이지만 그런식으로 탐색하지 않는다면 해당 재귀
함수는 완전 탐색 알고리즘이 아닌겁니다.

자 그러면 이번에는 아주 간단한 문제를 완전 탐색 재귀 함수(모든 가능한 조합을 탐색하는 재귀 함수)를 사용하여 풀어봅시다.

## 주어진 숫자를 만드는 경우의 수

1부터 n까지의 숫자를 중복 없이, 오름차순으로 더하여 목푯값을 만드는 모든 경우의 수를 출력하는 문제를 생각해 봅시다.

예를 들어 n이 5이고, 주어진 숫자도 5라면 5를 만드는 모든 경우의 수는
`1+4`, `2+3`, `5`로 총 세가지 이므로 결괏값은 3입니다. 여러 입력과 결과를 표로 나타내면 아래와 같습니다.

|n|목푯값|결괏값|비고 (경우의 수)|
|------|---|---|------|
|5|3|2|1+2, 3|
|5|4|2|1+3, 4|
|5|5|3|1+4, 2+3, 5|
|10|6|4|1+5, 2+4, 3+2+1, 6|

피보나치 문제를 풀기 전에 피보나치 문제가 재귀 함수로 풀리는 문제인지 확인해본 것처럼 이 문제를 풀기에 앞서 이 문제가 완전 탐색으로 풀 수 있는 문제인지, 그리고 재귀 함수로 풀 수 있는 문제인지 확인해 봅시다.

- 아래와 같은 이유로 이 문제는 완전 탐색 알고리즘으로 풀 수 있는 문제입니다.
    - 목푯값을 만들 수 있는 모든 경우의 수를 찾을 수 있습니다.
        - 예를 들어, n이 5라면 1부터 5까지의 각각의 숫자를 합산하거나, 합산하지 않는 방식으로 매번 분기를 만들어서 모든 경우의 수를 찾을 수 있습니다.
    - 문제의 해를 보장할 수 있습니다.
        - 목푯값이 주어지므로 해당 분기의 결괏값과 주어진 목푯값을 비교하여 문제의 해를 구할 수 있습니다.
        - 예를 들어, n이 5이고 목푯값이 5라면 모든 경우의 수 중 그들의 합이 5가 되는 것만이 해답이고 나머지는 아닙니다. 만약 목푯값이 주어지지 않으면 이 문제는 100%의 정확성으로는 풀 수
          없습니다.


- 아래와 같은 이유로 이 문제는 재귀 함수를 사용하여 풀 수 있습니다.
    - `1부터 n까지의 숫자를 중복 없이, 오름차순으로 더하여 목푯값을 만드는 모든 경우의 수를 구하는 문제`는
      `1부터 n까지의 각각의 수를 포함할 것인가 포함하지 않을 것인가`의 형태를 갖는 작은 문제의 꼴로 나눌 수 있습니다. 이렇게 나눈 작은 문제의 결괏값과  
      목푯값과 비교하면 해답을 구할 수 있는 문제입니다. 따라서 이 문제는 재귀 함수를 사용하여 풀 수 있는 문제입니다.


- 따라서 이 문제는 완전 탐색 문제이며, 동시에 재귀 함수를 사용하여 풀 수 있는 문제이므로 재귀 함수를 사용한 완전 탐색 알고리즘으로 풀 수 있는 문제입니다.

이 문제가 재귀 함수를 사용한 완전 탐색 알고리즘으로 풀 수 있는 문제임을 확인하였습니다.

이제 실제 재귀 함수를 작성해 봅시다. 이 문제를 푸는 재귀 함수는 아래와 같은 순서를 갖습니다.

1. 각각의 수를 합친 값이 목푯값과 같은지 확인합니다.
    1. 만족한다면 1을 반환합니다.
2. 각각의 수를 합친 값이 목푯값을 초과하는지 혹은 n이 0이하인지 확인합니다.
    1. 만족한다면 0을 반환합니다.
3. 현재의 수를 더하는 경우와 현재의 수를 더하지 않는 경우를 호출하고 이때 n의 값을 1 줄입니다.
4. 3번의 합을 반환합니다.

재귀 함수는 반드시 탈출 조건이 있어야 한다고 말씀드렸습니다. 1번과 2번이 이 재귀 함수의 탈출 조건입니다.

이를 코드로 나타내면 다음과 같습니다.

```python
# 함수는 현재 합(cur_sum)이 목표 합(target_sum)과 같아지면 1을 반환하고 
# 현재 합이 목표 합보다 크거나 n이 0이하이면 0을 반환합니다.
# 재귀적으로 모든 경우의 수를 탐색하며, 현재 숫자를 더하거나
# 더하지 않는 두 가지 경우를 모두 탐색합니다. 
# 이렇게 재귀 함수를 이용하여 가능한 모든 조합을 탐색하는 완전 탐색의 예시입니다.
def find_sum_combinations(n, target_sum, cur_sum):
    if cur_sum == target_sum:
        return 1
    if cur_sum > target_sum or n <= 0:
        return 0

    return find_sum_combinations(n - 1, target_sum, cur_sum) + \
            find_sum_combinations(n - 1, target_sum, cur_sum + n)
```

## 참고

[Brute-force search](https://en.wikipedia.org/wiki/Brute-force_search)

