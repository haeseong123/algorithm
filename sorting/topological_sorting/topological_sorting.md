# 위상 정렬

위상 정렬은 그래프의 각 노드의 모든 종속성을 방문한 후 해당 노드를 방문하는 것을 의미합니다. 아래 그림을 예로 들면, `11` 은 `5` 와 `7` 에 대해 종속성이 있습니다. 따라서 `11` 을 방문하기
전에 `5` 와 `7`을 먼저 방문해야 합니다. 마찬가지로 `8`을 방문하기 전에 `7`과 `3`을 방문하여야 합니다. 위상 정렬을 사용하면 아래와 같이 이러한 제약을 지키는 여러 순서를 찾을 수 있습니다.

- 5 -> 7 -> 3 -> 11 -> 8 -> 2 -> 9 -> 10
- 3 -> 5 -> 7 -> 8 -> 11 -> 2 -> 9 -> 10
- 5 -> 7 -> 3 -> 8 -> 11 -> 10 -> 9 -> 2
- 7 -> 5 -> 11 -> 3 -> 10 -> 8 -> 9 -> 2
- 5 -> 7 -> 11 -> 2 -> 3 -> 8 -> 9 -> 10
- 3 -> 7 -> 8 -> 5 -> 11 -> 10 -> 2 -> 9

![Directed_acyclic_graph_2](https://user-images.githubusercontent.com/50406129/233585379-fd022f72-7937-4db7-bf77-6368d7c692dc.svg)

위상 정렬은 순환(사이클)을 포함하지 않는 그래프에만 사용이 가능하며, 이러한 그래프를 유향 비순환 그래프(Directed Acyclic Graph, DAG)라고 부릅니다. 모든 DAG는 적어도 하나의 위상 정렬을
가지며, DAG의 위상 정렬을 선형 시간 내에 구성하는 알고리즘이 알려져 있습니다. 끊어진 구성 요소가 있는 DAG의 경우에도 위상 정렬은 가능합니다.

<details>
<summary>DAG</summary>

유향 비순환 그래프는 이름을 보면 알 수 있듯 방향성이 있고(Directed) 순환이 없는(Acyclic)
그래프(Graph) 입니다. 아래 그림을 참고해 주세요.

![dag](https://user-images.githubusercontent.com/50406129/233588397-f10c586d-8631-45dd-9d4a-9086408bdafb.png)
</details>

## 위상 정렬의 사용처

위상 정렬은 관계의 순서를 파악하고 싶을 때 사용합니다. 세상 대부분은 관계를 갖고 또 무척 많은 것들이 그 관계 속에서 순서를 가집니다. 그리고 우리는 많은 경우 그 순서를 파악하고 싶어 합니다. 따라서 위상
정렬은 아주 많은 곳에서 쓰입니다. 다음은 위상 정렬을 사용하는 몇 가지 예시입니다.

- 컴파일러
    - 컴파일러는 소스 코드를 기계어 코드로 변환합니다. 이 과정에서 각 함수나 변수를 참조하는 순서에 따라 코드를 생성해야 합니다. 이를 위해 컴파일러는 종속성을 파악해야 하고 종속성을 파악하기 위해 위상
      정렬을 사용합니다.
- 작업 스케줄링
    - 작업 스케줄링은 일련의 작업을 순서대로 실행하는 것을 의미합니다. 이러한 작업에서 각 작업이 다른 작업에 의존하는 경우 위상 정렬을 사용하여 실행 순서를 결정할 수 있습니다.
- 데이터베이스 관리
    - 데이터베이스 관리 시스템은 데이터베이스 내의 테이블을 처리할 때 종속성을 파악하기 위해 위상 정렬을 사용할 수 있습니다. 예를 들어, 외래 키가 있는 테이블을 로드하는 순서를 결정하는 데 사용됩니다.
- 프로젝트 관리
    - 프로젝트에서 여러 작업을 수행하고 각 작업이 다른 작업에 의존하는 경우 위상 정렬을 사용하여 작업의 실행 순서를 결정할 수 있습니다.
- 회로 설계
    - 회로 설계에서도 종속성을 파악하기 위해 위상 정렬을 사용할 수 있습니다. 회로는 다른 회로에 의존하는 경우가 많으며, 이러한 종속성을 파악하기 위해 위상 정렬을 사용할 수 있습니다.

참고로, 위상 정렬을 했는데 정상적으로 그래프 전체를 순회하지 못했다는 것은 그래프에 순환(사이클)이 있다는 것을 의미하기 때문에 위상 정렬은 주어진 그래프가 순환을 갖고 있는지 확인할 때 사용할 수도 있습니다.

## 구현

위상 정렬은 BFS를 활용한 Kahn's 알고리즘으로 구현할 수도 있고, DFS로 구현할 수도 있습니다. 인접 리스트 사용을 기준으로 두 방법 모두 노드 수에 엣지 수를 더한 `O(V + E)` 만큼의 시간 복잡도를
갖습니다.

우선 Kahn's 알고리즘을 먼저 알아봅시다.

### BFS로 구현: Kan's algorithm

Kan's algorithm의 수행 과정은 아래와 같습니다.

1. 그래프 내 모든 노드의 진입 차수(in-degree)를 계산합니다.
    1. in-degree란 나를 가리키는 변이 몇 개인지를 나타내는 것입니다. 예를 들어 `5` 를 가리키는 변은 하나도 없으니 `5` 의 진입 차수는 `0`입니다.
       `11` 을 가리키는 변은 총 두 개이니 `11` 의 진입 차수는 `2`입니다.
2. 진입 차수가 0인 모든 노드를 큐에 추가합니다.
3. 큐에서 노드를 하나씩 꺼내면서 해당 노드와 연결된 모든 노드의 진입 차수를 1씩 감소시킵니다.
4. 진입 차수가 0이 된 노드를 큐에 추가합니다.
5. 큐가 빌 때까지 3~4단계를 반복합니다.

<details>
<summary>in-degree</summary>

![Directed_acyclic_graph_2](https://user-images.githubusercontent.com/50406129/233585379-fd022f72-7937-4db7-bf77-6368d7c692dc.svg)

in-degree란 나를 가리키는 변이 몇 개인지를 나타낸 것입니다.

위 사진으로 보자면, `5` 를 가리키는 변은 하나도 없으니 `5` 의 진입 차수는 `0` 이고,
`11` 을 가리키는 변은 두 개이니 `11` 의 진입 차수는 `2`입니다.
</details>

Kan's algorithm을 코드로 구현하면 아래와 같습니다.

```python
from collections import deque


def topological_sort(graph):
    # 1
    in_degree = [0 for _ in range(len(graph))]
    for neighbors in graph:
        for neighbor in neighbors:
            in_degree[neighbor] += 1

    # 2
    queue = deque(i for i, value in enumerate(in_degree) if value == 0)

    result = []
    # 5
    while queue:
        node = queue.popleft()
        result.append(node)

        for neighbor in graph[node]:
            # 3
            in_degree[neighbor] -= 1

            # 5
            if in_degree[neighbor] == 0:
                queue.append(neighbor)

    return result
```

### DFS로 구현

DFS를 이용한 위상 정렬 알고리즘은 다음과 같은 순서로 동작합니다.

1. 그래프 내 모든 노드의 방문 상태를 초기화합니다.
2. 그래프 내 모든 노드를 순회하면서, 아직 방문하지 않은 노드에 대해 DFS 함수를 호출합니다.
3. DFS 함수에는 현재 노드를 방문 상태로 변경하고, 해당 노드의 이웃 노드를 순회하면서 아직 방문하지 않은 이웃 노드에 대해 DFS 함수를 재귀 호출합니다.
4. 현재 노드의 모든 이웃 노드를 방문한 후에는 현재 노드를 위상 정렬 결과 리스트에 추가합니다.
5. 반환 시 결과 리스트를 역순으로 반환합니다.

간단히 말해, 모든 노드에 대해 후위 순회 DFS를 하고 마지막에 결과 리스트를 역순으로 반환하면 됩니다.

이를 코드로 구현하면 아래와 같습니다.

```python
def topological_sort_dfs_postorder(graph):
    # 1
    visited = [False for _ in range(len(graph))]
    result = []

    def dfs(node):
        # 3
        visited[node] = True

        for neighbor in graph[node]:
            if not visited[neighbor]:
                # 2
                dfs(neighbor)

        # 4
        result.append(node)

    # 2
    for node in graph:
        if not visited[node]:
            dfs(node)

    # 5
    return result.reverse()
```

마지막으로 위상 정렬을 활용하여 문제를 하나 풀어보겠습니다.

## 동굴 탐험

오지 탐험가인 프로도는 탐험 도중 n개의 방으로 이루어진 지하 동굴을 탐험하게 되었습니다. 모든 방에는 0부터 n - 1 까지 번호가 붙어있고, 이 동굴에 들어갈 수 있는 유일한 입구는 0번 방과 연결되어 있습니다.
각 방들은 양방향으로 통행이 가능한 통로로 서로 연결되어 있는데, 서로 다른 두 방을 직접 연결하는 통로는 오직 하나입니다. 임의의 서로 다른 두 방 사이의 최단경로는 딱 한 가지만 있으며, 또한 임의의 두 방
사이에 이동이 불가능한 경우는 없습니다.

탐험에 앞서 이 지하 동굴의 지도를 손에 넣은 프로도는 다음과 같이 탐험 계획을 세웠습니다.

1. 모든 방을 적어도 한 번은 방문해야 합니다.
2. 특정 방은 방문하기 전에 반드시 먼저 방문할 방이 정해져 있습니다.
    1. 이는 A번 방은 방문하기 전에 반드시 B번 방을 먼저 방문해야 한다는 의미입니다.
    2. 어떤 방을 방문하기 위해 반드시 먼저 방문해야 하는 방은 없거나 또는 1개 입니다.
    3. 서로 다른 두 개 이상의 방에 대해 먼저 방문해야 하는 방이 같은 경우는 없습니다.
    4. 어떤 방이 먼저 방문해야 하는 방이면서 동시에 나중에 방문해야 되는 방인 경우는 없습니다.

위 계획 중 2-2, 2-3, 2-4는 순서를 지켜 방문해야 하는 두 방의 쌍이 A → B(A를 먼저 방문하고 B를 방문함) 형태로 유일함을 의미합니다. 즉, 프로도는 아래와 같은 형태로 방문순서가 잡히지 않도록
방문 계획을 세웠습니다.

- A → B, A → C (방문순서 배열 order = [...,[A,B],...,[A,C],...]) 형태로 A를 방문 후에 방문해야 할 방이 B와 C로 두 개 또는 그 이상인 경우
- X → A, Z → A (방문순서 배열 order = [...,[X,A],...,[Z,A],...]) 형태로 A를 방문하기 전에 방문해야 할 방이 X와 Z로 두 개 또는 그 이상 인 경우
- A → B → C (방문순서 배열 order = [...,[A,B],...,[B,C],...) 형태로 B처럼 A 방문 후이면서 동시에 C 방문 전인 경우

그리고 먼저 방문해야 할 방과 나중에 방문할 방을 반드시 연속해서 방문해야 할 필요는 없어 A방을 방문한 후 다른 방을 방문한 후 B방을 방문해도 좋습니다.

방 개수 n, 동굴의 각 통로들이 연결하는 두 방의 번호가 담긴 2차원 배열 path, 프로도가 정한 방문 순서가 담긴 2차원 배열 order가 매개변수로 주어질 때, 프로도가 규칙에 맞게 모든 방을 탐험할 수 있을
지 return 하도록 solution 함수를 완성해주세요.

### 제한 사항

- n은 2 이상 200,000 이하입니다.
- path 배열의 세로(행) 길이는 n - 1 입니다.
    - path 배열의 원소는 [방 번호 A, 방 번호 B] 형태입니다.
    - 두 방 A, B사이를 연결하는 통로를 나타냅니다.
    - 통로가 연결하는 두 방 번호가 순서없이 들어있음에 주의하세요.
- order 배열의 세로(행) 길이는 1 이상 (n / 2) 이하입니다.
    - order 배열의 원소는 [방 번호 A, 방 번호 B] 형태입니다.
    - A번 방을 먼저 방문한 후 B번 방을 방문해야 함을 나타냅니다.

### 입출력 예

|n|path|order|result|
|---|---|---|---|
|9|[[0,1],[0,3],[0,7],[8,1],[3,6],[1,2],[4,7],[7,5]]|[[8,5],[6,7],[4,1]]|true|
|9|[[8,1],[0,1],[1,2],[0,7],[4,7],[0,3],[7,5],[3,6]]|[[4,1],[5,2]]|true|
|9|[[0,1],[0,3],[0,7],[8,1],[3,6],[1,2],[4,7],[7,5]]|[[4,1],[8,7],[6,5]]|false|

### 입출력예에 대한 설명

입출력 예 #1: 동굴 그림은 아래와 같습니다.

![1](https://user-images.githubusercontent.com/50406129/233768587-44068976-bcec-4e64-a979-9865aa470fa5.png)

방문 순서를 지켜야 하는 방 번호는 다음과 같습니다.

- 6번 -> 7번
- 4번 -> 1번
- 8번 -> 5번

따라서 모든 방을 방문할 수 있는 방법 중 하나는 다음과 같습니다.

- 0번 → 3번 → 6번 → 3번 → 0번 → 7번 → 4번 → 7번 → 0번 → 1번 → 8번 → 1번 → 2번 → 1번 → 0번 → 7번 → 5번

입출력 예 #2

![2](https://user-images.githubusercontent.com/50406129/233768867-a5869025-c267-4d83-a6f2-177967b15109.png)

다음 순서로 각 방을 방문하면 됩니다.

- 0번 → 7번 → 4번 → 7번 → 5번 → 7번 → 0번 → 3번 → 6번 → 3번 → 0번 → 1번 → 8번 → 1번 → 2번

입출력 예 #3

![3](https://user-images.githubusercontent.com/50406129/233768869-b92076de-c447-4bfb-8b4d-69731db180f9.png)

규칙에 맞게 모든 방을 방문할 수 있는 방법이 없습니다.

### 문제 풀이

문제에서는 특정 방을 방문하기 전에 먼저 방문할 방이 정해져 있는 경우가 있다고 명시되어 있습니다. 이 경우, 우리는 선행 방문이 필요한 방들의 관계를 그래프로 나타낼 수 있습니다. 이 그래프는 방들 사이의 관계를
나타내며, 방 번호가 정점, 선행 방문의 관계가 간선으로 표현됩니다.

여기서 방문 순서를 짜는 것은 그래프를 DFS 또는 BFS로 탐색하는 것과 동일합니다. 하지만, 주의할 점은 방문 순서가 정해져 있기 때문에, `어떤 방을 방문하기 이전에 다른 방을 방문해야 하는 경우가 있다는 것`
입니다. 따라서 우리는 이러한 경우에 따른 코드만 추가하면 됩니다.

만약 해당 그래프가 순환을 갖는다면 `order` 를 만족하며 모든 방을 순회할 방법은 없습니다. 예를 들자면, A 방을 방문하기 위해서 B를 방문해야 하고 B를 방문하기 위해서 A를 방문해야 하는 경우를 생각해
봅시다. 이 구조는 순환을 갖기 때문에 A도 B도 절대 방문할 수가 없습니다. 이러한 사실을 토대로 그래프에 순환이 없다면 모든 방을 방문할 수 있는 것이므로 True를, 그래프에 순환이 존재한다면 False를
반환하면 됩니다.

1. path를 순회하며 graph를 작성합니다.
2. order를 순회하며 src2dest를 작성합니다.
    1. 이때 destination 변수도 함께 작성합니다. destination은 사전 방문해야 하는 노드가 있는 노드들을 모은 집합입니다. 만약 사전 방문해야 하는 노드를 방문할 시 해당되는
       destination을 삭제합니다.
3. stack에 0을 넣습니다.
4. stack에서 노드를 꺼냅니다.
5. visited[node]를 True로 바꿉니다.
6. 노드를 확인합니다.
    1. 노드가 src인 경우
        1. destination에서 src와 연결된 dest를 삭제합니다.
        2. 해당 노드에서 갈 수 있는 다른 노드 중 방문하지 않은 노드를 전부 추가합니다.
        3. 만약 destination을 이전에 방문했다면 destination에서 갈 수 있는 다른 노드를 전부 추가합니다.
    2. 노드가 destination의 원소인 경우
        1. continue
    3. 노드가 둘 다 아닌 경우
        1. 해당 노드에서 갈 수 있는 다른 노드 중 방문하지 않은 노드를 전부 추가합니다.
7. stack이 텅 빌 때까지 4~6을 반복합니다.
8. destination이 텅 비었다면 모든 src와 dest를 전부 돌았다는 것이므로 True를 반환하고 destination에 값이 있다면 그래프에 순환이 존재해서 그래프를 전부 순회하진 못했다는 것이므로
   False를 반환합니다.

이를 코드로 나타내면 아래와 같습니다.

```python
def solution(n, path, order):
    # 1
    graph = [[] for _ in range(n)]
    for a, b in path:
        graph[a].append(b)
        graph[b].append(a)

    # 2
    destination = set()
    src2dest = [0 for _ in range(n)]
    for src, dest in order:
        destination.add(dest)
        src2dest[src] = dest

    # 3
    stack = [0]
    visited = [False for _ in range(n)]

    # 4~7
    while stack:
        node = stack.pop()
        dest = src2dest[node]
        visited[node] = True

        # node가 source인 경우
        if dest:
            destination.remove(dest)
            stack.extend(filter(lambda x: not visited[x], graph[node]))
            if visited[dest]:
                stack.extend(filter(lambda x: not visited[x], graph[dest]))
        # node가 destination의 원소인 경우
        elif node in destination:
            continue
        # node가 둘 다 아닌 경우
        else:
            stack.extend(filter(lambda x: not visited[x], graph[node]))

    # 8
    return not destination
```

## 출처

- [위상 정렬 개념 및 구현](https://yoongrammer.tistory.com/86#%EC%9D%91%EC%9A%A9)
- [위상 정렬: 위키](https://ko.wikipedia.org/wiki/%EC%9C%84%EC%83%81%EC%A0%95%EB%A0%AC)
- [위상 정렬: 위키2](https://en.wikipedia.org/wiki/Topological_sorting)
- [동굴 탐험: 프로그래머스](https://school.programmers.co.kr/learn/courses/30/lessons/67260?language=python3)
