# 활동 선택 문제

활동 선택 문제(Activity selection problem)이란, 일부 활동들이 주어졌을 때, 각 활동은 시작 시간과 끝나는 시간을 가지며, 겹치지 않는 상태에서 최대한 많은 활동을 선택하는 문제입니다. 이
문제는 그리디 알고리즘을 사용하여 솔루션을 찾는 것이 항상 최적의 솔루션이라고 증명되었습니다.

이 문제를 해결하기 위해, 일반적으로는 다음과 같은 방법을 사용합니다.

1. 모든 활동을 끝나는 시간을 기준으로 정렬합니다.
2. 가장 빨리 끝나는 활동을 선택하고, 기준 시간을 선택한 활동의 끝나는 시간으로 설정합니다.
3. 정렬된 리스트를 전부 순회할 때까지 반복합니다.

이 문제는 최적 부분 구조를 갖고 부분 반복 문제를 포함하기 때문에 DP로도 풀 수 있습니다. 다만, 탐욕 알고리즘으로 풀어도 항상 최적해를 도출하므로 더 느린 DP를 사용할 필요는 없습니다. 그래도 DP와 그리디
알고리즘 두 방법으로 활동 선택 문제를 풀어보겠습니다.

## DP

각 활동이 시작하는 시간과 끝나는 시간이 담긴 두 배열 start와 finish를 인자로 받아, 최대한 많은 활동을 선택하는 경우의 수를 구하는 dp는 각각의 활동을 마지막으로 선택했을 때 가능한 최대 활동 수를
저장하고, 뒤에서부터 구해가는 방식으로 구현할 수 있습니다.

종료시간이 오름차순으로 정렬되어 있다는 가정하에, 현재 고려하는 i번째 활동보다 이전에 선택한 활동들 중 끝나는 시간이 i번째 활동의 시작시간보다 작거나 같은 것들을 모두 비교해 최댓값을 구하는 방식으로 dp를
채워나갑니다.

마지막으로 dp 배열에서 최댓값을 반환합니다.

이를 코드로 나타내면 아래와 같습니다.

```python
def activity_selection_problem_dp(start, finish):
    n = len(start)
    dp = [0] * n
    dp[0] = 1

    for i in range(1, n):
        dp[i] = 1
        for j in range(i):
            if finish[j] <= start[i]:
                dp[i] = max(dp[i], dp[j] + 1)

    return max(dp)
```

DP로 작성한 코드의 시간 복잡도는 `O(N^2)` 입니다.

## 그리디

DP 코드도 어렵진 않지만, 그리디 알고리즘을 활용하면 훨씬 쉽고 빠르게 문제를 해결할 수 있습니다. 그리디 알고리즘을 활용하는 코드는 현재 선택할 수 있는 활동 중 시작 시간이 내가 마지막으로 선택한 활동의 끝나는
시간보다 나중이면(같아도 됨) 그것을 선택하고 아니면 넘어가면 됩니다.

위 예제와 마찬가지로 finish 오름차순으로 정렬되어 있다고 가정하겠습니다.

이를 코드로 나타내면 아래와 같습니다.

```python
def activity_selection_problem_greedy(start, finish):
    selected = [finish[0]]
    for f in finish[1:]:
        if selected[-1] <= f:
            selected.append(f)

    return len(selected)
```

finish 배열을 순회하는 것이 전부이므로 시간 복잡도는 `O(N)` 입니다.

문제를 하나 풀어보겠습니다.

## 회의실 배정

한 개의 회의실이 있는데 이를 사용하고자 하는 N개의 회의에 대하여 회의실 사용표를 만들려고 합니다. 각 회의 I에 대해 시작시간과 끝나는 시간이 주어져 있고, 각 회의가 겹치지 않게 하면서 회의실을 사용할 수 있는
회의의 최대 개수를 찾아봅시다. 단, 회의는 한번 시작하면 중간에 중단될 수 없으며 한 회의가 끝나는 것과 동시에 다음 회의가 시작될 수 있습니다. 회의의 시작시간과 끝나는 시간이 같을 수도 있습니다. 이 경우에는
시작하자마자 끝나는 것으로 생각하면 됩니다.

### 입력

첫째 줄에 회의의 수 N(1 ≤ N ≤ 100,000)이 주어집니다. 둘째 줄부터 N+1 줄까지 각 회의의 정보가 주어지는데 이것은 공백을 사이에 두고 회의의 시작시간과 끝나는 시간이 주어집니다. 시작 시간과 끝나는
시간은 231-1보다 작거나 같은 자연수 또는 0입니다.

### 출력

첫째 줄에 최대 사용할 수 있는 회의의 최대 개수를 출력합니다.

### 예제

입력

```
11
1 4
3 5
0 6
5 7
3 8
5 9
6 10
8 11
8 12
2 13
12 14
```

출력

```
4
```

### 문제 풀이

활동 선택 문제입니다. 그리디 알고리즘을 사용하여 풀면 됩니다.

아래는 그리디 알고리즘을 사용하여 최적해를 구하는 코드입니다.

```python
times = sorted([tuple(map(int, input().split())) for _ in range(int(input()))], key=lambda x: (x[1], x[0]))
selected = [times[0]]

for i in range(1, len(times)):
    if selected[-1][1] <= times[i][0]:
        selected.append(times[i])

print(len(selected))
```

## 출처

- [Activity selection problem](https://en.wikipedia.org/wiki/Activity_selection_problem)
- [회의실 배정](https://www.acmicpc.net/problem/1931)
