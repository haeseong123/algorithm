# 거스름돈 문제

거스름돈 문제(Change-making problem)는 구매 가격과 지불한 금액이 주어졌을 때, 거스름돈으로 돌려줄 동전의 개수를 최소화하는 문제입니다.

이 문제에서 동전의 가치가 서로 배수 형태를 이룬다면, 그리디 알고리즘을 적용하여 항상 최적의 해를 구할 수 있습니다. 이렇게 그리디 알고리즘이 항상 최적의 해를 도출하는 경우 이러한 동전 시스템을 표준(
canonical) 시스템이라고 합니다. 만약 동전의 가치가 서로 배수 형태를 이루지 않는다면 그리디 알고리즘을 적용할 수 없고 이러한 시스템은 canonical한 시스템이 아닙니다.

거스름돈 문제에서 그리디 알고리즘을 적용하는 방법은 거슬러 줄 수 있는 동전 중 가장 큰 동전으로 거슬러 주는 방법입니다. 예를 들어, 500원, 100원, 50원 10원짜리 동전이 있고, 거슬러 줄 돈이
760원이라면, 그리디 알고리즘은 먼저 500원짜리 동전 1개를 거슬러 주고, 남은 260원을 처리합니다. 이후 100원짜리 동전 2개를 거슬러 주고, 마지막으로 10원짜리 동전 6개를 거슬러 주면, 총 9개의
동전을 사용하여 거스름돈을 주게 됩니다.

이제 실제 문제를 풀어봅시다.

## 타로의 거스름돈 문제

타로는 자주 JOI잡화점에서 물건을 삽니다. JOI잡화점에는 잔돈으로 500엔, 100엔, 50엔, 10엔, 5엔, 1엔이 충분히 있고, 언제나 거스름돈 개수가 가장 적게 잔돈을 줍니다. 타로가 JOI잡화점에서
물건을 사고 카운터에서 1000엔 지폐를 한장 냈을 때, 받을 잔돈에 포함된 잔돈의 개수를 구하는 프로그램을 작성해 주세요.

### 입력

입력은 한줄로 이루어져있고, 타로가 지불할 돈(1 이상 1000미만의 정수) 1개가 쓰여져 있습니다.

### 예제

입력1

```
380
```

출력1

```
4
```

###

입력2

```
1
```

출력2

```
15
```

### 문제 풀이

간단히 말하면, 입력으로 주어진 수 N에 대해 1000-N을 거슬러 주어야 하는데, 이때 거슬러줄 잔돈의 개수를 최소로 하는 문제입니다.

가장 큰 동전부터 최대한 많이 사용하는 식으로 그리디 알고리즘을 적용하면 최적해를 구할 수 있습니다. 순서는 다음과 같습니다.

1. 거슬러 줘야 할 돈 이하의 동전으로 거슬러 줘야 할 돈을 나눕니다.
2. 몫은 잔돈의 개수에 더하고 나머지는 새로운 거슬러 줘야 할 돈입니다.
3. 모든 잔돈에 대해 이를 반복합니다.

코드는 다음과 같습니다.

```python
cashbox = [500, 100, 50, 10, 5, 1]
change = 1000 - int(input())
cnt = 0

for cash in cashbox:
    if cash > change:
        continue
    quotient, remainder = divmod(change, cash)
    cnt += quotient
    change = remainder

print(cnt)
```

## 출처

- [거스름돈](https://www.acmicpc.net/problem/5585)
